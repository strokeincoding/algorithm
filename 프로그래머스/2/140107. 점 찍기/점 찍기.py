import math

def solution(k, d): # 시간 복잡도 해결 1사분면만 이용하는걸 생각 이중 for문 x
    answer = 0
    max_a = d // k  # a의 최대값 초기 설정

    for b in range(max_a + 1):
        while max_a >= 0 and (k * max_a)**2 + (k * b)**2 > d**2:
            max_a -= 1  # 가능한 a의 최대값 줄이기
        answer += (max_a + 1)  # 원점으로부터 d 이내의 a 값의 개수를 더하기

    return answer



/*
k의 역할: a와 b는 각각 x축과 y축 방향으로의 단계를 나타냅니다. 각 단계는 k만큼 움직입니다. 즉, a와 b의 값이 1 증가할 때마다, 실제 좌표계에서는 k만큼 더 멀리 이동합니다.

최대 한계 계산: d는 원점으로부터의 최대 허용 거리입니다. 만약 a*k 또는 b*k가 d보다 크다면, 그 점은 d를 초과하여 원점으로부터 너무 멀리 떨어져 있게 됩니다. 이러한 점들은 조건에 부합하지 않습니다.

정수 나눗셈의 사용: d // k는 d를 k로 나눈 후, 결과를 정수로 내림한 값입니다. 이는 a 또는 b가 취할 수 있는 최대 정수값을 제공합니다. 예를 들어, d가 10이고 k가 3이라면, d // k는 3이 됩니다. 이는 a 또는 b가 3 이상이 되면 a*k 또는 b*k가 10을 초과하게 되므로, a와 b는 0, 1, 2, 3의 값을 가질 수 있음을 의미합니다.

이렇게 max_limit을 계산함으로써, 우리는 a와 b가 취할 수 있는 값의 범위를 적절하게 제한하여, 원점으로부터의 거리 d를 초과하는 점들을 효율적으로 배제할 수 있습니다.
*/
